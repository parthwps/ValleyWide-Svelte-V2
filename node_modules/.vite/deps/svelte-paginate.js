import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-RVLVW3YK.js";
import "./chunk-6TJCVOLN.js";

// node_modules/svelte-paginate/paginate.js
function paginate({ items, pageSize, currentPage }) {
  return items.slice((currentPage - 1) * pageSize, (currentPage - 1) * pageSize + pageSize);
}

// node_modules/svelte-paginate/types.js
var SymbolType;
(function(SymbolType2) {
  SymbolType2["PREVIOUS_PAGE"] = "PREVIOUS_PAGE";
  SymbolType2["NEXT_PAGE"] = "NEXT_PAGE";
  SymbolType2["ELLIPSIS"] = "ELLIPSIS";
})(SymbolType || (SymbolType = {}));

// node_modules/svelte-paginate/generateNavigationOptions.js
function generateNavigationOptions({ totalItems, pageSize, currentPage, limit, showStepOptions = false }) {
  const totalPages = Math.ceil(totalItems / pageSize);
  const limited = limit && totalPages > getLimitThreshold(limit);
  const options = limited ? generateLimitedOptions({ totalPages, limit, currentPage }) : generateUnlimitedOptions({ totalPages });
  return showStepOptions ? addStepOptions({ options, currentPage, totalPages }) : options;
}
function generateUnlimitedOptions({ totalPages }) {
  return new Array(totalPages).fill(null).map((_, index) => ({
    type: "number",
    value: index + 1
  }));
}
function generateLimitedOptions({ totalPages, limit, currentPage }) {
  const boundarySize = limit * 2 + 2;
  const firstBoundary = 1 + boundarySize;
  const lastBoundary = totalPages - boundarySize;
  const totalShownPages = firstBoundary + 2;
  if (currentPage <= firstBoundary - limit) {
    return Array(totalShownPages).fill(null).map((_, index) => {
      if (index === totalShownPages - 1) {
        return {
          type: "number",
          value: totalPages
        };
      } else if (index === totalShownPages - 2) {
        return {
          type: "symbol",
          symbol: SymbolType.ELLIPSIS,
          value: firstBoundary + 1
        };
      }
      return {
        type: "number",
        value: index + 1
      };
    });
  } else if (currentPage >= lastBoundary + limit) {
    return Array(totalShownPages).fill(null).map((_, index) => {
      if (index === 0) {
        return {
          type: "number",
          value: 1
        };
      } else if (index === 1) {
        return {
          type: "symbol",
          symbol: SymbolType.ELLIPSIS,
          value: lastBoundary - 1
        };
      }
      return {
        type: "number",
        value: lastBoundary + index - 2
      };
    });
  } else if (currentPage >= firstBoundary - limit && currentPage <= lastBoundary + limit) {
    return Array(totalShownPages).fill(null).map((_, index) => {
      if (index === 0) {
        return {
          type: "number",
          value: 1
        };
      } else if (index === 1) {
        return {
          type: "symbol",
          symbol: SymbolType.ELLIPSIS,
          value: currentPage - limit + (index - 2)
        };
      } else if (index === totalShownPages - 1) {
        return {
          type: "number",
          value: totalPages
        };
      } else if (index === totalShownPages - 2) {
        return {
          type: "symbol",
          symbol: SymbolType.ELLIPSIS,
          value: currentPage + limit + 1
        };
      }
      return {
        type: "number",
        value: currentPage - limit + (index - 2)
      };
    });
  }
  return [];
}
function addStepOptions({ options, currentPage, totalPages }) {
  return [
    {
      type: "symbol",
      symbol: SymbolType.PREVIOUS_PAGE,
      value: currentPage <= 1 ? 1 : currentPage - 1
    },
    ...options || [],
    {
      type: "symbol",
      symbol: SymbolType.NEXT_PAGE,
      value: currentPage >= totalPages ? totalPages : currentPage + 1
    }
  ];
}
function getLimitThreshold(limit) {
  const maximumUnlimitedPages = 3;
  const numberOfBoundaryPages = 2;
  return limit * 2 + maximumUnlimitedPages + numberOfBoundaryPages;
}

// node_modules/svelte-paginate/PaginationNav.svelte
var file = "node_modules/svelte-paginate/PaginationNav.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
var get_next_slot_changes = (dirty) => ({});
var get_next_slot_context = (ctx) => ({});
var get_prev_slot_changes = (dirty) => ({});
var get_prev_slot_context = (ctx) => ({});
var get_ellipsis_slot_changes = (dirty) => ({});
var get_ellipsis_slot_context = (ctx) => ({});
var get_number_slot_changes = (dirty) => ({ value: dirty & /*options*/
4 });
var get_number_slot_context = (ctx) => ({ value: (
  /*option*/
  ctx[12].value
) });
function create_if_block_3(ctx) {
  let current;
  const next_slot_template = (
    /*#slots*/
    ctx[9].next
  );
  const next_slot = create_slot(
    next_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_next_slot_context
  );
  const next_slot_or_fallback = next_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      if (next_slot_or_fallback)
        next_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (next_slot_or_fallback)
        next_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (next_slot_or_fallback) {
        next_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (next_slot) {
        if (next_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            next_slot,
            next_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              next_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_next_slot_changes
            ),
            get_next_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(next_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(next_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (next_slot_or_fallback)
        next_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(59:83) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const prev_slot_template = (
    /*#slots*/
    ctx[9].prev
  );
  const prev_slot = create_slot(
    prev_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_prev_slot_context
  );
  const prev_slot_or_fallback = prev_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (prev_slot_or_fallback) {
        prev_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (prev_slot) {
        if (prev_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            prev_slot,
            prev_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              prev_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_prev_slot_changes
            ),
            get_prev_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prev_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prev_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(47:87) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const ellipsis_slot_template = (
    /*#slots*/
    ctx[9].ellipsis
  );
  const ellipsis_slot = create_slot(
    ellipsis_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_ellipsis_slot_context
  );
  const ellipsis_slot_or_fallback = ellipsis_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (ellipsis_slot_or_fallback)
        ellipsis_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (ellipsis_slot_or_fallback)
        ellipsis_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (ellipsis_slot_or_fallback) {
        ellipsis_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ellipsis_slot) {
        if (ellipsis_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            ellipsis_slot,
            ellipsis_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              ellipsis_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_ellipsis_slot_changes
            ),
            get_ellipsis_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(ellipsis_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(ellipsis_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (ellipsis_slot_or_fallback)
        ellipsis_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(43:82) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const number_slot_template = (
    /*#slots*/
    ctx[9].number
  );
  const number_slot = create_slot(
    number_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_number_slot_context
  );
  const number_slot_or_fallback = number_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (number_slot_or_fallback)
        number_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (number_slot_or_fallback)
        number_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (number_slot_or_fallback) {
        number_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (number_slot) {
        if (number_slot.p && (!current || dirty & /*$$scope, options*/
        260)) {
          update_slot_base(
            number_slot,
            number_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              number_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_number_slot_changes
            ),
            get_number_slot_context
          );
        }
      } else {
        if (number_slot_or_fallback && number_slot_or_fallback.p && (!current || dirty & /*options*/
        4)) {
          number_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(number_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(number_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (number_slot_or_fallback)
        number_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(39:6) {#if option.type === 'number'}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { style: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "#000000");
      attr_dev(path, "d", "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z");
      add_location(path, file, 64, 12, 2357);
      set_style(svg, "width", "24px");
      set_style(svg, "height", "24px");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 60, 10, 2253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(60:26)            ",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { style: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "#000000");
      attr_dev(path, "d", "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z");
      add_location(path, file, 52, 12, 1969);
      set_style(svg, "width", "24px");
      set_style(svg, "height", "24px");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 48, 10, 1865);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(48:26)            ",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text("...");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, "...");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file, 44, 10, 1707);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(44:30)            ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let span;
  let t_value = (
    /*option*/
    ctx[12].value + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file, 40, 10, 1539);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      4 && t_value !== (t_value = /*option*/
      ctx2[12].value + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(40:51)            ",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*option*/
      ctx2[12].type === "number"
    )
      return 0;
    if (
      /*option*/
      ctx2[12].type === "symbol" && /*option*/
      ctx2[12].symbol === SymbolType.ELLIPSIS
    )
      return 1;
    if (
      /*option*/
      ctx2[12].type === "symbol" && /*option*/
      ctx2[12].symbol === SymbolType.PREVIOUS_PAGE
    )
      return 2;
    if (
      /*option*/
      ctx2[12].type === "symbol" && /*option*/
      ctx2[12].symbol === SymbolType.NEXT_PAGE
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*option*/
        ctx[12]
      )
    );
  }
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, role: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t = claim_space(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "option");
      attr_dev(span, "role", "presentation");
      toggle_class(
        span,
        "number",
        /*option*/
        ctx[12].type === "number"
      );
      toggle_class(
        span,
        "prev",
        /*option*/
        ctx[12].type === "symbol" && /*option*/
        ctx[12].symbol === SymbolType.PREVIOUS_PAGE
      );
      toggle_class(
        span,
        "next",
        /*option*/
        ctx[12].type === "symbol" && /*option*/
        ctx[12].symbol === SymbolType.NEXT_PAGE
      );
      toggle_class(
        span,
        "disabled",
        /*option*/
        ctx[12].type === "symbol" && /*option*/
        ctx[12].symbol === SymbolType.NEXT_PAGE && /*currentPage*/
        ctx[0] >= /*totalPages*/
        ctx[1] || /*option*/
        ctx[12].type === "symbol" && /*option*/
        ctx[12].symbol === SymbolType.PREVIOUS_PAGE && /*currentPage*/
        ctx[0] <= 1
      );
      toggle_class(
        span,
        "ellipsis",
        /*option*/
        ctx[12].type === "symbol" && /*option*/
        ctx[12].symbol === SymbolType.ELLIPSIS
      );
      toggle_class(
        span,
        "active",
        /*option*/
        ctx[12].type === "number" && /*option*/
        ctx[12].value === /*currentPage*/
        ctx[0]
      );
      add_location(span, file, 24, 4, 688);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration_dev(span, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(span, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & /*options*/
      4) {
        toggle_class(
          span,
          "number",
          /*option*/
          ctx[12].type === "number"
        );
      }
      if (!current || dirty & /*options, SymbolType*/
      4) {
        toggle_class(
          span,
          "prev",
          /*option*/
          ctx[12].type === "symbol" && /*option*/
          ctx[12].symbol === SymbolType.PREVIOUS_PAGE
        );
      }
      if (!current || dirty & /*options, SymbolType*/
      4) {
        toggle_class(
          span,
          "next",
          /*option*/
          ctx[12].type === "symbol" && /*option*/
          ctx[12].symbol === SymbolType.NEXT_PAGE
        );
      }
      if (!current || dirty & /*options, SymbolType, currentPage, totalPages*/
      7) {
        toggle_class(
          span,
          "disabled",
          /*option*/
          ctx[12].type === "symbol" && /*option*/
          ctx[12].symbol === SymbolType.NEXT_PAGE && /*currentPage*/
          ctx[0] >= /*totalPages*/
          ctx[1] || /*option*/
          ctx[12].type === "symbol" && /*option*/
          ctx[12].symbol === SymbolType.PREVIOUS_PAGE && /*currentPage*/
          ctx[0] <= 1
        );
      }
      if (!current || dirty & /*options, SymbolType*/
      4) {
        toggle_class(
          span,
          "ellipsis",
          /*option*/
          ctx[12].type === "symbol" && /*option*/
          ctx[12].symbol === SymbolType.ELLIPSIS
        );
      }
      if (!current || dirty & /*options, currentPage*/
      5) {
        toggle_class(
          span,
          "active",
          /*option*/
          ctx[12].type === "number" && /*option*/
          ctx[12].value === /*currentPage*/
          ctx[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(24:2) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let current;
  let each_value = (
    /*options*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "pagination-nav");
      add_location(div, file, 22, 0, 627);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*options, SymbolType, currentPage, totalPages, handleOptionClick, $$scope*/
      271) {
        each_value = /*options*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let options;
  let totalPages;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationNav", slots, ["number", "ellipsis", "prev", "next"]);
  const dispatch = createEventDispatcher();
  let { totalItems = 0 } = $$props;
  let { pageSize = 1 } = $$props;
  let { currentPage = 1 } = $$props;
  let { limit = void 0 } = $$props;
  let { showStepOptions = false } = $$props;
  function handleOptionClick(option) {
    dispatch("setPage", { page: option.value });
  }
  const writable_props = ["totalItems", "pageSize", "currentPage", "limit", "showStepOptions"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PaginationNav> was created with unknown prop '${key}'`);
  });
  const click_handler = (option) => handleOptionClick(option);
  $$self.$$set = ($$props2) => {
    if ("totalItems" in $$props2)
      $$invalidate(4, totalItems = $$props2.totalItems);
    if ("pageSize" in $$props2)
      $$invalidate(5, pageSize = $$props2.pageSize);
    if ("currentPage" in $$props2)
      $$invalidate(0, currentPage = $$props2.currentPage);
    if ("limit" in $$props2)
      $$invalidate(6, limit = $$props2.limit);
    if ("showStepOptions" in $$props2)
      $$invalidate(7, showStepOptions = $$props2.showStepOptions);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    generateNavigationOptions,
    SymbolType,
    dispatch,
    totalItems,
    pageSize,
    currentPage,
    limit,
    showStepOptions,
    handleOptionClick,
    totalPages,
    options
  });
  $$self.$inject_state = ($$props2) => {
    if ("totalItems" in $$props2)
      $$invalidate(4, totalItems = $$props2.totalItems);
    if ("pageSize" in $$props2)
      $$invalidate(5, pageSize = $$props2.pageSize);
    if ("currentPage" in $$props2)
      $$invalidate(0, currentPage = $$props2.currentPage);
    if ("limit" in $$props2)
      $$invalidate(6, limit = $$props2.limit);
    if ("showStepOptions" in $$props2)
      $$invalidate(7, showStepOptions = $$props2.showStepOptions);
    if ("totalPages" in $$props2)
      $$invalidate(1, totalPages = $$props2.totalPages);
    if ("options" in $$props2)
      $$invalidate(2, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*totalItems, pageSize, currentPage, limit, showStepOptions*/
    241) {
      $:
        $$invalidate(2, options = generateNavigationOptions({
          totalItems,
          pageSize,
          currentPage,
          limit,
          showStepOptions
        }));
    }
    if ($$self.$$.dirty & /*totalItems, pageSize*/
    48) {
      $:
        $$invalidate(1, totalPages = Math.ceil(totalItems / pageSize));
    }
  };
  return [
    currentPage,
    totalPages,
    options,
    handleOptionClick,
    totalItems,
    pageSize,
    limit,
    showStepOptions,
    $$scope,
    slots,
    click_handler
  ];
}
var PaginationNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      totalItems: 4,
      pageSize: 5,
      currentPage: 0,
      limit: 6,
      showStepOptions: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationNav",
      options,
      id: create_fragment.name
    });
  }
  get totalItems() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set totalItems(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSize() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSize(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentPage() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentPage(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showStepOptions() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showStepOptions(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationNav_default = PaginationNav;

// node_modules/svelte-paginate/LightPaginationNav.svelte
var file2 = "node_modules/svelte-paginate/LightPaginationNav.svelte";
function add_css(target) {
  append_styles(target, "svelte-s5ru8s", ".light-pagination-nav.svelte-s5ru8s .pagination-nav{display:flex;justify-content:center;background:#FFF;border-radius:3px;box-shadow:0 1px 2px rgba(0, 0, 0, 0.3)}.light-pagination-nav.svelte-s5ru8s .option{padding:10px;display:flex;align-items:center;justify-content:center;transition:0.2s all ease-out;user-select:none;color:hsl(200, 90%, 10%)}.light-pagination-nav.svelte-s5ru8s .option.number,.light-pagination-nav.svelte-s5ru8s .option.ellipsis{padding:10px 15px}.light-pagination-nav.svelte-s5ru8s .option:hover{background:rgba(0, 0, 0, 0.1);cursor:pointer}.light-pagination-nav.svelte-s5ru8s .option.active{color:hsl(200, 70%, 50%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHRQYWdpbmF0aW9uTmF2LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZQSxtQ0FBcUIsQ0FBUyxlQUFpQixDQUM3QyxPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDekMsQ0FDQSxtQ0FBcUIsQ0FBUyxPQUFTLENBQ3JDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixVQUFVLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQzdCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLEtBQUssQ0FBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FDMUIsQ0FFQSxtQ0FBcUIsQ0FBUyxjQUFlLENBQzdDLG1DQUFxQixDQUFTLGdCQUFrQixDQUM5QyxPQUFPLENBQUUsSUFBSSxDQUFDLElBQ2hCLENBQ0EsbUNBQXFCLENBQVMsYUFBZSxDQUMzQyxVQUFVLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDOUIsTUFBTSxDQUFFLE9BQ1YsQ0FDQSxtQ0FBcUIsQ0FBUyxjQUFnQixDQUM1QyxLQUFLLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQzFCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkxpZ2h0UGFnaW5hdGlvbk5hdi5zdmVsdGUiXX0= */");
}
function create_fragment2(ctx) {
  let div;
  let paginationnav;
  let current;
  const paginationnav_spread_levels = [
    /*$$props*/
    ctx[0]
  ];
  let paginationnav_props = {};
  for (let i = 0; i < paginationnav_spread_levels.length; i += 1) {
    paginationnav_props = assign(paginationnav_props, paginationnav_spread_levels[i]);
  }
  paginationnav = new PaginationNav_default({
    props: paginationnav_props,
    $$inline: true
  });
  paginationnav.$on(
    "setPage",
    /*setPage_handler*/
    ctx[1]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(paginationnav.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(paginationnav.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "light-pagination-nav svelte-s5ru8s");
      add_location(div, file2, 4, 0, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(paginationnav, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const paginationnav_changes = dirty & /*$$props*/
      1 ? get_spread_update(paginationnav_spread_levels, [get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      paginationnav.$set(paginationnav_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationnav.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationnav.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(paginationnav);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightPaginationNav", slots, []);
  function setPage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ PaginationNav: PaginationNav_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props, setPage_handler];
}
var LightPaginationNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightPaginationNav",
      options,
      id: create_fragment2.name
    });
  }
};
var LightPaginationNav_default = LightPaginationNav;

// node_modules/svelte-paginate/DarkPaginationNav.svelte
var file3 = "node_modules/svelte-paginate/DarkPaginationNav.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1tvwpem", ".dark-pagination-nav.svelte-1tvwpem .pagination-nav{display:flex;justify-content:center;background:hsl(200, 80%, 5%);border-radius:3px;box-shadow:0 1px 2px rgba(0, 0, 0, 0.3)}.dark-pagination-nav.svelte-1tvwpem .option{padding:10px;display:flex;align-items:center;justify-content:center;transition:0.2s all ease-out;user-select:none;color:hsl(200, 90%, 90%)}.dark-pagination-nav.svelte-1tvwpem .option svg path{fill:hsl(200, 90%, 90%)}.dark-pagination-nav.svelte-1tvwpem .option:first-child{border-radius:3px 0 0 3px}.dark-pagination-nav.svelte-1tvwpem .option:last-child{border-radius:0 3px 3px 0}.dark-pagination-nav.svelte-1tvwpem .option.number,.dark-pagination-nav.svelte-1tvwpem .option.ellipsis{padding:10px 15px}.dark-pagination-nav.svelte-1tvwpem .option:hover{background:#000;cursor:pointer}.dark-pagination-nav.svelte-1tvwpem .option.active{color:hsl(200, 100%, 50%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGFya1BhZ2luYXRpb25OYXYuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVlBLG1DQUFvQixDQUFTLGVBQWlCLENBQzVDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsVUFBVSxDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQzdCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDekMsQ0FDQSxtQ0FBb0IsQ0FBUyxPQUFTLENBQ3BDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixVQUFVLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQzdCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLEtBQUssQ0FBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FDMUIsQ0FDQSxtQ0FBb0IsQ0FBUyxnQkFBa0IsQ0FDN0MsSUFBSSxDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUN6QixDQUNBLG1DQUFvQixDQUFTLG1CQUFxQixDQUNoRCxhQUFhLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FDekIsQ0FDQSxtQ0FBb0IsQ0FBUyxrQkFBb0IsQ0FDL0MsYUFBYSxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQzNCLENBQ0EsbUNBQW9CLENBQVMsY0FBZSxDQUM1QyxtQ0FBb0IsQ0FBUyxnQkFBa0IsQ0FDN0MsT0FBTyxDQUFFLElBQUksQ0FBQyxJQUNoQixDQUNBLG1DQUFvQixDQUFTLGFBQWUsQ0FDMUMsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLE9BQ1YsQ0FDQSxtQ0FBb0IsQ0FBUyxjQUFnQixDQUMzQyxLQUFLLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQzNCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRhcmtQYWdpbmF0aW9uTmF2LnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let div;
  let paginationnav;
  let current;
  const paginationnav_spread_levels = [
    /*$$props*/
    ctx[0]
  ];
  let paginationnav_props = {};
  for (let i = 0; i < paginationnav_spread_levels.length; i += 1) {
    paginationnav_props = assign(paginationnav_props, paginationnav_spread_levels[i]);
  }
  paginationnav = new PaginationNav_default({
    props: paginationnav_props,
    $$inline: true
  });
  paginationnav.$on(
    "setPage",
    /*setPage_handler*/
    ctx[1]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(paginationnav.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(paginationnav.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "dark-pagination-nav svelte-1tvwpem");
      add_location(div, file3, 4, 0, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(paginationnav, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const paginationnav_changes = dirty & /*$$props*/
      1 ? get_spread_update(paginationnav_spread_levels, [get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      paginationnav.$set(paginationnav_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationnav.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationnav.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(paginationnav);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DarkPaginationNav", slots, []);
  function setPage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ PaginationNav: PaginationNav_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props, setPage_handler];
}
var DarkPaginationNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DarkPaginationNav",
      options,
      id: create_fragment3.name
    });
  }
};
var DarkPaginationNav_default = DarkPaginationNav;
export {
  DarkPaginationNav_default as DarkPaginationNav,
  LightPaginationNav_default as LightPaginationNav,
  PaginationNav_default as PaginationNav,
  paginate
};
//# sourceMappingURL=svelte-paginate.js.map
